#!/usr/bin/env python3

import re
import argparse
import logging
import sys
import time
import timestring
from jira_issue_manager import JiraIssueManager
import constants
from blackduck_client import BlackduckClient

logging.basicConfig(
    format='%(asctime)s:%(levelname)s:%(message)s',
    stream=sys.stderr,
    level=logging.INFO
)


def is_scan_completed(blackduck_client, version):
    ''' Check if Blackduck scan has completed. '''
    for _ in range(60):
        result = blackduck_client.get_bom_status(version)
        bom_status = result.get('status')
        if 'PROCESSING' in bom_status:
            logging.info('Waiting for Blackduck scan to finish...')
            time.sleep(60)
        else:
            return timestring.Date(result.get('lastScanDate')).date
    logging.error('A scan has been running for more than an hour. Timeout.')
    sys.exit(1)


def categorize_scan_results(bom_vuln_entries, issues):
    ''' Categorize vulnerability entries into tickets to close, update, and open. '''
    ticket_close_list = []
    ticket_update_list = []
    ticket_open_list = []

    issue_map = {(issue['fields'][constants.BD_COMPONENT_FIELD].lower(
    ), issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower()): issue for issue in issues}
    component_map = {
        (component['componentName'].lower(), component['componentVersionName'].lower()): component
        for component in bom_vuln_entries
    }

    for comp in bom_vuln_entries:
        key = (comp['componentName'].lower(),
               comp['componentVersionName'].lower())
        issue = issue_map.get(key)

        if issue:
            if (issue['fields'][constants.BD_SEVERITY_FIELD] != comp['severity'] or
                sorted(re.split(',', str(issue['fields'][constants.BD_CVES_FIELD]))) !=
                    sorted(re.split(',', comp['cves']))):
                ticket_info = {}
                ticket_info['updated_fields'] = comp
                ticket_info['jira_key'] = issue['key']
                ticket_update_list.append(ticket_info)
            elif issue['fields']['status']['name'] == 'Done':
                # 03-04-2025, VULN Jira project is changed so that Done status is
                # used exclusively by automation.  The ticket is transitioned to
                # 'Done' when a vulnerable component is not detected by scan.
                # If it shows up on BD scan again, the ticket needs to be
                # reopened.
                ticket_info = {}
                ticket_info['updated_fields'] = comp
                ticket_info['jira_key'] = issue['key']
                ticket_update_list.append(ticket_info)
        else:
            ticket_open_list.append(comp)

    ticket_close_list = [issue for issue in issues
                         if (issue['fields'][constants.BD_COMPONENT_FIELD].lower(),
                             issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower())
                         not in component_map]
    return ticket_close_list, ticket_update_list, ticket_open_list


def updated_ticket_fields(issue, bom_vuln_updates):
    ''' Update issue fields with new vulnerability information. '''
    updated_fields = bom_vuln_updates.copy()
    issue_cves = re.split(
        ',', getattr(issue.fields, constants.BD_CVES_FIELD, '') or '')
    bom_cves = re.split(
        ',', bom_vuln_updates.get('cves', '') or '')
    updated_fields['cves'] = ','.join(
        sorted({cve for cve in issue_cves + bom_cves if cve}))
    updated_fields['severity'] = min(
        [getattr(issue.fields, constants.BD_SEVERITY_FIELD),
         bom_vuln_updates.get('severity')],
        key=lambda s: constants.SEVERITY_LIST.index(s)
    )

    links = re.split('{anchor}', getattr(issue.fields, constants.BD_DETAIL_FIELD))[
        1].splitlines()
    bom_links = bom_vuln_updates.get('links', '').splitlines()
    updated_fields['links'] = '\n'.join(
        set(link for link in links + bom_links if link))
    return updated_fields


def close_ticket(issue):
    ''' Close the JIRA ticket if it's not in an excluded status. '''
    status = issue.fields.status.name
    key = issue.key
    if status not in constants.DONE_STATUSES:
        logging.info(f'Closing ticket: {key}')
        jira.transition_issue(
            issue,
            constants.WORKFLOW_DONE_ID,
            {}
        )
        jira.client.add_comment(issue, 'Mark ticket as done. Removed by Blackduck Hub.')


def reopen_ticket(issue):
    ''' Reopen a ticket. '''
    summary = issue.fields.summary
    key = issue.key
    jira.transition_issue(
        issue,
        constants.WORKFLOW_TO_DO_ID,
        {}
    )
    jira.client.add_comment(
        issue,
        f'{key} is reopened.  Either CVE(s) has changed, or {summary} is reintroduced')


def should_reopen_ticket(issue, updates):
    '''
    Determine if a ticket should be reopened.  Don't reopen if:
    * Issue in excluded status
    * Severity is low
    * only CVEs removed
    '''
    # Get current and new values
    status = issue.fields.status.name
    old_cves = getattr(issue.fields, constants.BD_CVES_FIELD, '')
    new_cves = updates.get('cves', '')
    old_severity = getattr(issue.fields, constants.BD_SEVERITY_FIELD)
    # Default to old severity if not present
    new_severity = updates.get('severity', old_severity)

    # compare new and old cves
    # if no new cve and only removed cve, return False
    old_cve_set = set(cve for cve in re.split(',', old_cves or '') if cve)
    new_cve_set = set(cve for cve in re.split(',', new_cves or '') if cve)
    added_cves = new_cve_set - old_cve_set
    removed_cves = old_cve_set - new_cve_set

    if not added_cves and removed_cves:
        return False

    # if ticket is in excluded status or severity is low, return False
    if (status in constants.DO_NOT_REOPEN_STATUSES or
            new_severity == 'LOW'):
        return False

    return True


def create_ticket(issue_info, project_name, version_name):
    '''
    Create a new Jira ticket
    associate it with tickets of the same 3rd party library
    '''
    related_issues = jira.search_related_issues(issue_info['componentName'],
                                                issue_info['componentVersionName'],
                                                project_name
                                                )
    issue = jira.new_issue(issue_info, project_name, version_name)
    logging.info(f'Created ticket: {issue.key}')
    if getattr(issue.fields, constants.BD_SEVERITY_FIELD) == 'LOW':
        jira.transition_issue(
            issue,
            constants.WORKFLOW_DONE_ID,
            {}
        )
        jira.client.add_comment(
            issue, f'{issue.key} is automatically closed due to low severity.')
    if related_issues:
        for r in related_issues:
            logging.info(f'Link {issue.key} with {r.key}')
            jira.create_issue_link(issue.key, r.key)


def process_scan_changes(jira, bom_vulnerabilities,
                         existing_issues, project_name, version_name):
    ''' Update JIRA tickets based on scan results from Blackduck. '''
    tickets_need_close, tickets_need_update, tickets_need_open = categorize_scan_results(
        bom_vulnerabilities, existing_issues)

    for ticket_info in tickets_need_close:
        issue = jira.client.issue(ticket_info['key'])
        close_ticket(issue)

    for ticket_info in tickets_need_open:
        logging.info(
            f"Open new ticket for {ticket_info['componentName']}:"
            f"{ticket_info['componentVersionName']}")
        create_ticket(ticket_info, project_name, version_name)

    for ticket_info in tickets_need_update:
        updates = ticket_info['updated_fields']
        issue = jira.client.issue(ticket_info['jira_key'])
        jira.update_issue(issue, updates, project_name, version_name)
        if should_reopen_ticket(issue, updates):
            reopen_ticket(issue)


def process_knowledgebase_changes(
        jira,
        tickets_need_update,
        tickets_need_close,
        project_name,
        version_name):
    ''' Update JIRA tickets based on changes from Blackduck knowledgebase. '''
    for t in tickets_need_close:
        logging.debug(
            f"Does {t['componentName']}:{t['componentVersionName']} exist in Jira?")
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        if issue:
            close_ticket(issue)

    for t in tickets_need_update:
        logging.debug(
            f"need to update {t['componentName']}:{t['componentVersionName']} in Jira")
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        if issue:
            updates = updated_ticket_fields(issue, t)
            logging.info(f'Update ticket, {issue.key}')
            jira.update_issue(issue, updates, project_name, version_name)
            if should_reopen_ticket(issue, updates):
                reopen_ticket(issue)
        else:
            logging.info(
                f"Create new issue for {t['componentName']}:{t['componentVersionName']}")
            create_ticket(t, project_name, version_name)


# Main execution
parser = argparse.ArgumentParser(
    'Create or update JIRA tickets based on Blackduck vulnerabilities')
subparsers = parser.add_subparsers(
    help='Blackduck vulnerability types: scan or knowledgebase.',
    dest='type')
scan_parser = subparsers.add_parser('scan')
knowledgebase_parser = subparsers.add_parser('knowledgebase')

scan_parser.add_argument(
    '-p',
    '--project_name',
    required=True,
    help='Project name in Blackduck.')
scan_parser.add_argument(
    '-v',
    '--version_name',
    required=True,
    help='Project version.')
knowledgebase_parser.add_argument(
    '-d',
    '--start_date',
    required=True,
    help='Start date of knowledgebase activities')

args = parser.parse_args()

blackduck = BlackduckClient()
jira = JiraIssueManager()

if args.type == 'scan':
    current_issues = jira.find_project_version_issues(
        args.project_name, args.version_name)
    logging.info(
        f'Checking {args.project_name} {args.version_name} BOM vulnerabilities against Jira.')
    project = blackduck.get_project_by_name(args.project_name)
    version = blackduck.get_project_version(project, args.version_name)
    last_scan_date = is_scan_completed(blackduck, version)
    bom_vulns = blackduck.prepare_vulnerability_entries(version)
    process_scan_changes(
        jira,
        bom_vulns,
        current_issues,
        args.project_name,
        args.version_name)

if args.type == 'knowledgebase':
    start_date = timestring.Date(args.start_date).date
    params = {'limit': '0'}
    projects = blackduck.hub_client.get_resource('projects')
    for project in projects:
        # Skip the projects that we don't or no longer maintain
        if project['name'] in constants.EXCLUDED_PROJECTS:
            continue
        logging.info(f"Checking Blackduck Hub updates for {project['name']}")
        versions = blackduck.hub_client.get_resource('versions', parent=project, params=params)
        if versions is not None:
            for version in versions:
                version_name = version.get('versionName')
                # Skip snapshot, beta, and other invalid versions
                if re.search(r'[^0-9.]', version_name):
                    logging.info(f'Skip {version_name}')
                    continue
                logging.info(f'Checking version {version_name}')
                last_scan_date = is_scan_completed(blackduck, version)
                if last_scan_date > start_date:
                    logging.info(
                        f"Last scan, {last_scan_date} is newer than {start_date} "
                        f"for {version_name}.  Skip checking against Jira.")
                    continue
                tickets_to_update, tickets_to_close = blackduck.get_version_journal(
                    version, start_date)
                process_knowledgebase_changes(
                    jira,
                    tickets_to_update,
                    tickets_to_close,
                    project['name'],
                    version_name)
